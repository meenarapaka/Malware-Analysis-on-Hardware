#!/usr/bin/env python
# coding: utf-8

# In[1]:


import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')
plt.rcParams['figure.figsize'] = (10.0, 8.0)
import seaborn as sns

from sklearn.svm import SVC
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score


# In[2]:


Malware= pd.read_excel("../624/malware dataset.xlsx")
Malware.head()


# In[3]:


Malware.isnull().any()
Malware['instructions']=Malware['instructions'].fillna(Malware['instructions'].mean())
Malware.describe()


# In[4]:


#bar plot for independent vs target variable
for i in Malware.columns:
    if i!='class':
        fig = plt.figure(figsize = (10,6))
        sns.barplot(x = 'class', y = i, data = Malware)


# In[5]:


#Distribution of target variable
sns.countplot(Malware['class'])


# In[6]:


from sklearn.preprocessing import LabelEncoder
le_color = LabelEncoder()
Malware['class'] = le_color.fit_transform(Malware['class'])
Malware['class'].unique()


# In[7]:


#correlation plot
numeric_data = Malware.select_dtypes(include=[np.number])
corr = numeric_data.corr()
sns.heatmap(corr)


# In[8]:


plt.figure(figsize=(12,6))
sns.heatmap(Malware.corr(),annot=True)


# In[9]:


#Removal of outliers by interquartile range method
Q1 = Malware.quantile(0.25)
Q3 = Malware.quantile(0.75)
IQR = Q3 - Q1


# In[10]:


Malware=Malware[~((Malware < (Q1 - 1.5 * IQR)) |(Malware > (Q3 + 1.5 * IQR))).any(axis=1)]
Malware.shape


# In[11]:


#removing multicollinearity by variance inflation factor method

y = Malware['class']
Malware = Malware.drop(columns = ['class'])
Malware.head()


# In[ ]:





# In[12]:


from statsmodels.stats.outliers_influence import variance_inflation_factor
[variance_inflation_factor(Malware.values, j) for j in range(Malware.shape[1])]

def calculate_vif(x):
    thresh = 5.0
    output = pd.DataFrame()
    k = x.shape[1]
    vif = [variance_inflation_factor(x.values, j) for j in range(x.shape[1])]
    for i in range(1,k):        
        a = np.argmax(vif)        
        if vif[a] <= thresh :
            break
        if i == 1 :          
            output = x.drop(x.columns[a], axis = 1)
            #print(output)
            vif = [variance_inflation_factor(output.values, j) for j in range(output.shape[1])]
        elif i > 1 :
            output = output.drop(output.columns[a],axis = 1)
            #print(output)
            vif = [variance_inflation_factor(output.values, j) for j in range(output.shape[1])]
            
    return(output)
    
train_out = calculate_vif(Malware) 
Malware = Malware.drop(columns=train_out.columns, axis=1)
Malware.info()
#train_out.info()  
Malware['class'] = y


# In[13]:


print(Malware.info())


# Separating out the features
X = Malware.iloc[:, :-1].values  

# Separating out the target
y = Malware.iloc[:,-1].values

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)

# Standardizing the features
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()

X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)


from imblearn.over_sampling import SMOTE
sm = SMOTE(random_state=2)
X_train_res, y_train_res = sm.fit_sample(X_train, y_train)
#fitting random forest classifier to the training dataset
from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(max_depth=10, random_state=0)
classifier.fit(X_train_res, y_train_res.ravel())
y_pred = classifier.predict(X_test)

from sklearn.metrics import confusion_matrix  
from sklearn.metrics import accuracy_score
# from sklearn.metrics import recall 

from sklearn.metrics import classification_report

report = classification_report(y_test, y_pred)
print(report)

cm = confusion_matrix(y_test, y_pred)  
print(cm)
print('Accuracy' + str(accuracy_score(y_test, y_pred))) 
# Visualising the Test set results

classifier.fit(X_train_res, y_train_res.ravel())


# In[14]:


# Fitting Decision Tree Classification to the Training set
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score
treeclassifier = DecisionTreeClassifier(criterion = 'gini', random_state = 8, splitter = 'random')
treeclassifier.fit(X_train_res, y_train_res.ravel())

Y_pred = treeclassifier.predict(X_test)
from sklearn.metrics import confusion_matrix  
from sklearn.metrics import accuracy_score
# from sklearn.metrics import recall 

cm = confusion_matrix(y_test, Y_pred)  
print(cm)  
print('Accuracy' + str(accuracy_score(y_test, Y_pred))) 


from sklearn.metrics import classification_report

report = classification_report(y_test, y_pred)
print(report)


# In[15]:


from sklearn.decomposition import PCA
pca = PCA(n_components=2)
principalComponents = pca.fit_transform(Malware.iloc[:, :-1].values)
principalDf = pd.DataFrame(data = principalComponents, columns = ['principal component 1', 'principal component 2'])

Malware_final = pd.concat([principalDf, Malware['class']], axis = 1)

Malware_final.head()

fig = plt.figure(figsize = (8,8))
ax = fig.add_subplot(1,1,1) 
ax.set_xlabel('Principal Component 1', fontsize = 15)
ax.set_ylabel('Principal Component 2', fontsize = 15)
ax.set_title('2 component PCA', fontsize = 20)
# targets = ['backdoor', 'benign', 'rootkit', 'trojan', 'virus', 'worm']
targets = [0, 1, 2, 3, 4, 5]
colors = ['k', 'g', 'r','y','m','b']
for target, color in zip(targets,colors): 
    indicesToKeep = np.where((Malware_final['class']) == (target))
    ax.scatter(Malware_final.iloc[indicesToKeep]['principal component 1'].values
                   , Malware_final.iloc[indicesToKeep]['principal component 2'].values,
                    c = color,  cmap='viridis' , s = 50)
ax.legend(targets)
ax.grid()


# In[ ]:





# In[ ]:




